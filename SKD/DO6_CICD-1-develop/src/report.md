# Basic CI/CD

Разработка простого **CI/CD** для проекта *SimpleBashUtils*. Сборка, тестирование, развертывание.

<br>

## Содержание

1. [Настройка gitlab-runner](#part-1-настройка-gitlab-runner) \
  1.1. [Установка виртуальной машины](#поднять-виртуальную-машину-ubuntu-server-2204-lts) \
  1.2. [Установка gitlab-runner](#скачать-и-установить-на-виртуальную-машину-gitlab-runner) \
  1.3. [Регистрация в gitlab-runner](#запустить-gitlab-runner-и-зарегистрировать-его-для-использования-в-текущем-проекте-do6_cicd)
2. [Cборка](#part-2-сборка) \
  2.1. [Добавление этапа сборки](#напиcать-этап-для-ci-по-сборке-приложений-из-проекта-c2_simplebashutils) \
  2.2. [Неподготовленная оболочка](#неподготовленная-оболочка) \
  2.3. [Проверка сборки проекта](#проверка-сборки-проекта)
3. [Тест кодстайла](#part-3-тест-кодстайла) \
  3.1. [Добавление этапа теста кодстайла](#напиcать-этап-для-ci-который-запускает-скрипт-кодстайла-clang-format) \
  3.2. [Ошибочный вывод пайплайна](#проверить-зафейлился-ли-пайплайн-если-совершена-ошибка-в-кодстайле) \
  3.3. [Корректный вывод пайплайна](#исправить-ошибку-в-форматировании-кода-и-проверить-результат)
4. [Интеграционные тесты](#part-4-интеграционные-тесты) \
  4.1. [Добавление этапа интеграционных тестов](#написать-этап-для-ci-который-запускает-интеграционные-тесты-из-того-же-проекта) \
  4.2. [Ошибочный вывод пайплайна](#проверить-зафейлился-ли-пайплайн-если-обнаруживаются-ошибочные-рузльтаты-интеграционных-тестов) \
  4.3. [Корректный вывод пайплайна](#исправить-ошибку-для-успешного-прохождения-тестов-и-проверить-результат)
5. [Этап деплоя](#part-5-этап-деплоя) \
  5.1. [Установка виртуальной машины](#поднять-вторую-виртуальную-машину-ubuntu-server-2204-lts) \
  5.2. [Статическая маршрутизация между двумя машинами](#статическая-маршрутизация-между-двумя-машинами) \
  5.3. [Генерация ssh-ключей](#генерация-ssh-ключей) \
  5.4. [Относительно bash-скрипта](#написать-bash-скрипт-который-при-помощи-ssh-и-scp-копирует-файлы-полученные-после-сборки-артефакты-в-директорию-usrlocalbin-второй-виртуальной-машины) \
  5.5. [Добавление этапа деплоя](#написать-этап-для-cd-который-«разворачивает»-проект-на-другой-виртуальной-машине) \
  5.6. [Настройка ssh-агента](#настройка-ssh-агента) \
  5.7. [Проверка этапа деплоя](#проверка-этапа-деплоя)
6. [Дополнительно. Уведомления](#part-6-дополнительно-уведомления) \
  6.1. [Создание бота и получение данных](#настроить-уведомления-о-успешномнеуспешном-выполнении-пайплайна-через-бота-с-именем-«nealpadm-do6-cicd»-в-telegram) \
  6.2. [Настройка бота](#настройка-бота) \
  6.3. [Проверка работы бота](#проверка-работы-бота)

<br>




## [Part 1. Настройка **gitlab-runner**](#содержание)

**== Задание ==**

### Поднять виртуальную машину *Ubuntu Server 22.04 LTS*

![image](images/part1-00.png) 

> В дальнейшем работа на Ubutu Server будет производиться через openssh на декстопной версии Ubuntu

### Скачать и установить на виртуальную машину **gitlab-runner**

> Был выбран метод установки gitlab-runner через [бинарный файл с официального сайта](https://docs.gitlab.com/runner/install/linux-manually.html)

1. Загрузить бинарный файл <br>
```sh
sudo curl -L --output /usr/local/bin/gitlab-runner "https://s3.dualstack.us-east-1.amazonaws.com/gitlab-runner-downloads/latest/binaries/gitlab-runner-linux-amd64"
```
2. Дать файлу разрешение на исполнение: <br>
```sh
sudo chmod +x /usr/local/bin/gitlab-runner
```
3. Создать пользователя GitLab CI <br>
```sh
sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash
```
4. Установить как службу <br>
```sh
sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner
```
5. Запустить службу
```sh
sudo gitlab-runner start
```

![image](images/part1-01.png) 

### Запустить **gitlab-runner** и зарегистрировать его для использования в текущем проекте (*DO6_CICD*)

> Для регистрации понадобятся URL и токен, которые можно получить на страничке задания на платформе

![image](images/part1-03-0.png)  

- Зарегистрировать gitlab-runner
```ssh
sudo gitlab-runner register
```
> Для этого необходимо ввести данные при регистрации: <br>
> 1. Cвой URL-адрес GitLab
> 2. Cвой регистрационный токен
> 3. Название раннера
> 4. Теги для заданий, разделенные запятыми
> 5. Тип исполнителя

![image](images/part1-02.png) 

<br>




## [Part 2. Сборка](#содержание)

### Напиcать этап для CI по сборке приложений из проекта *C2_SimpleBashUtils*

- В корне репозитория создать файл `.gitlab-ci.yml`

```ssh
touch .gitlab-ci.yml
```

- Добавить в файл этап запуска сборки через мейк файл из проекта C2.

> Настроим также этап, чтобы файлы, полученные после сборки (артефакты), сохранялись со сроком хранения 30 дней.

![image](images/part1-03.png) 

### Неподготовленная оболочка

- При пуше мы столкнемся со следующей ошибкой

![image](images/part1-04.png) 

> Раннер нас предупреждает, что среда не подготовлена к запуску. Причиной послужила дефолтная конфигурация gitlab-runner, производящая очистку терминала при выходе из оболочки shell. Комментирование строк данного скрипта устраняет данную ошибку

- Закомментируем строки в `/home/gitlab-runner/.bash_logout`

![image](images/part1-05.png) 

### Проверка сборки проекта

- Перезапустим пайплайн и проверим пропала ли ошибка

![image](images/part1-07.png) 

- Как можно увидеть, сборка была успешно осуществлена, исполняемые файлы были сохранены на 30 дней

![image](images/part1-06.png) 

<br>




## [Part 3. Тест кодстайла](#содержание)

### Напиcать этап для CI, который запускает скрипт кодстайла (clang-format)

![image](images/part1-08.png) 

### Проверить зафейлился ли пайплайн, если совершена ошибка в кодстайле

- Проверим сначала вывод команды локально

![image](images/part1-09.png) 

- Как и ожидалось - пайплайн зафейлился

![image](images/part1-10.png) 

- Вывод пайплайна совпал с локальным выводом команды

![image](images/part1-11.png) 

### Исправить ошибку в форматировании кода и проверить результат

- Результат работы пайплайна

![image](images/part1-12.png) 

- Теперь проект успешно проходит тест кодстайла

![image](images/part1-13.png) 

<br>




## [Part 4. Интеграционные тесты](#содержание)

### Написать этап для CI, который запускает интеграционные тесты из того же проекта

![image](images/part1-14.png) 

### Проверить зафейлился ли пайплайн, если обнаруживаются ошибочные рузльтаты интеграционных тестов

- Проверим сначала вывод интеграционных тестов локально

![image](images/part1-15.png) 

- Проверяем, что пайплайн зафейлился

![image](images/part1-16.png) 

- Вывод пайплайна совпал с локальным выводом результатов

![image](images/part1-17.png) 

### Исправить ошибку для успешного прохождения тестов и проверить результат

- Результат работы пайплайна

![image](images/part1-18.png) 

- Проект успешно проходит интеграционные тесты

![image](images/part1-19.png) 

<br>




## [Part 5. Этап деплоя](#содержание)

### Поднять вторую виртуальную машину Ubuntu Server 22.04 LTS

![image](images/part5-01.png) 

### Статическая маршрутизация между двумя машинами

- Настроим адаптеры обоих машин на внутреннюю сеть


```sh
sudo nano /etc/yonnrose/00-network-manager-all.yaml
```

![image](images/part5-02.png) 
![image](images/part5-03.png) 

- Обязательно принимаем изменения в настройках адаптеров

```sh
sudo netplan apply
```

- Проверим соединение между машинами

![image](images/part5-04.png) 
![image](images/part5-05.png) 

### Генерация ssh-ключей

- Для начала сгенерируем пары ключей для каждой машины

```sh
ssh-keygen
```
![image](images/part5-06.png) 
![image](images/part5-07.png) 

- Добавим открытый ключ второй машины с вывода `cat /home/yonnrose/.ssh/id_rsa.pub` в ssh ключи gitlab для работы с проектом на удаленной машине

![image](images/part5-08.png) 

### Написать bash-скрипт, который при помощи ssh и scp копирует файлы, полученные после сборки (артефакты), в директорию /usr/local/bin второй виртуальной машины

> Данная часть предполагает создание отдельного скрипта и применение его в стейдже. 

### Написать этап для CD, который «разворачивает» проект на другой виртуальной машине

> Данный этап будет запускаться вручную при условии, что все предыдущие этапы прошли успешно

- Теперь, когда на удаленной машине есть проект, допишем этап деплоя в `.gitlab-ci.yml`

![image](images/part5-09.png) 

- Написать bash-скрипт, который при помощи ssh и scp копирует файлы, полученные после сборки (артефакты), в директорию /usr/local/bin второй виртуальной машины

![image](images/part5-09-01.png)

> Этап деплоя описан таким образом, что для получения доступа к удаленному серверу применяется ssh-агент. Для его работы необходимо будет выполнить определенный ряд действий

### Настройка ssh-агента

- Следующие изменения будут происходить от суперпользователя, поэтому сразу же перейдем в этот режим на машине с развернутым раннером

```sh
sudo su
```

- Перейдем в настройки раннера и обозначим ему где искать ssh-агента. Для этого в файле конфигураций добавим строку `environment = ["SSH_AUTH_SOCK=/tmp/ssh-agent"]`

```sh
nano /etc/gitlab-runner/config.toml
```
![image](images/part5-13.png) 

- Далее необходимо сохранить отпечаток удаленного сервера. Для этого ключ удаленного сервера необходимо добавить в файл `known_hosts` в домашнем каталоге пользователя gitlab-runner

```sh
ssh-keyscan -H 192.10.10.2 >> /home/gitlab-runner/.ssh/known_hosts
```
![image](images/part5-12.png) 

- Так как раннеру необходим приватный ключ, для того, чтобы не возникало проблем с ключами доступа к директории `/home/yonnrose/.ssh` и ее содержимому - скопируем закрытый ключ также в домашний каталог пользователя gitlab-runner

```sh
cp /home/yonnrose/.ssh/id_rsa /home/gitlab-runner/.ssh/
```
![image](images/part5-14.png) 


- Скопируем содержимое нашего открытого ssh-ключа на удаленный сервер

> Отвечаем `yes` на подтверждение подключения и в следующем действии вводим пароль от удаленной машины

```sh
ssh-copy-id yonnrose@192.10.10.2
```
![image](images/part5-15.png) 

- После успешной настройки ssh-агента есть один небольшой штришок. Так как наш скрипт производит копирование в директорию, в которой у нас нет прав - напишем дополнительный скрипт configure_sudo.sh который дописывает строку `yonnrose ALL=(ALL) NOPASSWD:ALL' на удаленной машине в файле `/etc/sudoers` что дает права суперпользователя без ввода пароля. 

![image](images/part5-09-02.png)

- Либо сделать это вручную на удаленной машине server через команду:

```sh
sudo visudo
```
![image](images/part5-10.png) 

- Теперь можно с уверенностью сказать, что этап деплоя не выдаст ошибок. Перезапустим службу раннера и тем самым закончим настройку ssh-агента

```sh
sudo systemctl restart gitlab-runner.service
```

### Проверка этапа деплоя

- После пуша обновленного `gitlab-ci.yml` проверяем состояние пайплайна

![image](images/part5-16.png)

- Как видим пайплайн остановился после CI стадий и ждет нашей команды. Запустим этап деплоя

![image](images/part5-17.png)

- Судя по выводу раннера деплой прошел успешно. Проверим наличие полученных исполняемых файлов в директории `/usr/local/bin` на удаленной машине

![image](images/part5-18.png)


## [Part 6. Дополнительно. Уведомления](#содержание)

### Настроить уведомления о успешном/неуспешном выполнении пайплайна через бота с именем "yonnrose_DO6_CICD_bot" в Telegram

> Текст уведомления будет содержать информацию об успешности прохождения как этапа CI, так и этапа CD. <br>
> В остальном текст уведомления может быть произвольным.

- Найдем в телеграме через поиск `BotFather`

- Запустим бота и напишем `/newbot`

> В диалоге необходимо будет написать: <br>
> - имя бота `yonnrose DO6 CI/CD» в Telegram` <br>
> - юзернейм для бота (имя должно быть уникальным и заканчиваться на `bot`)

![image](images/part6-01.png)

- В результате мы получили `API` бота. Теперь найдем бота `getmyid_bot` и напишем ему `/start` для получения нашего `ID`

![image](images/part6-02.png)

> В данном задании опишем notify для уведомления в телеграм бот внутри `gitlab-ci.yml`


### Настройка бота

- Теперь перейдем непосредственно к этапам раннера и внесем некоторые коррективы

> Добавим переменные TELEGRAM_BOT_TOKEN и TELEGRAM_CHAT_ID:
> - Зайдем на сайт GitLab, перейдем в раздел CI/CD и добавим наши переменные

![image](images/part6-03.png)

> Напишем скрипт Через `.notify: &notify` определим набор команд для уведомлений, которые будут использованы во всех этапах
> - Формируем сообщение боту, исходя из результата предыдущего job'а
> - Отправляем сформированное сообщение боту с помощью curl и ssh
> - У каждого стейджа в `after_script` указываем вызов вышеупомянутого набора команд

![image](images/part6-04.png)

### Проверка работы бота

- Протестируем уведомления от всех успешных или зафейленного пайплайна

> можем удостовериться что сообщение ушло в самом пайплане:

![image](images/part6-06.png)

> ну и смотрим сообщения в телеграм-боте:

![image](images/part6-05.png)

### [К содержанию](#содержание)